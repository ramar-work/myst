#!/bin/bash -
# -------------------------------------------- #
# myst.sh
#
# Summary
# -------
# An administration interface for Myst sites.
#
# Author
# ------
#	Antonio R. Collins II (ramar.collins@gmail.com, rc@tubularmodular.com)
# Copyright 2016-Present, Tubular Modular
# Original Author Date: Tue Jul 26 07:26:29 2016 -0400
# 
# Usage
# -----
# TBD
# 	
# TODO
# ----
# - Output a production ready package?
#	- Be able to build from JSON, XML, or something
# - Handle setup tasks and tooling ( like database connections and maintenance ) 
# - Convert cli scripts to Java, C or C++
# - Make sure user matches server user
# - Add options for SSL (since the cert may be involved at Tomcat's level) 
#
# -------------------------------------------- #

# const 
PROGRAM_NAME=`basename $0`
SYMNAME=myst
PNAME=Myst
CONF_FILE=/etc/myst.conf
LIB_FILE=share/myst/mystlib.sh
SRCREPO=https://github.com/tubularmodular/myst
STABLE_BRANCH=master
CHECK="sed|xxd -h|git -h|md5sum -h|diff"

# unconst
DIR=
THIS_SITE=
SRC=.
DO_SES=0
DO_GENVHOST=0
DO_ACTIVATE=0
DO_CREATE=0
UPDATE=0
NO_GIT=0
VERBOSE=0
ERR_NODIR=1
ERR_NONAME=2
ENGINE=
VHOST_FILE=
BACKUP_FILE=
DO_FINALIZE=0
DO_ENABLE=0
DO_DISABLE=0
DO_LIST=0


# An error function
err() {
	STATUS=${2:-0}
	printf "$PROGRAM_NAME: $1\n" > /dev/stderr
	exit $STATUS
}


# A usage function
#-e, --ses                Enable search engine safe URLs
usage() {
	STATUS=${2:-0}
	cat <<USAGES
$PROGRAM_NAME:
Instance options:
-c, --create             Create a new instance. 
-u, --update <arg>       Update the instance at <arg>. 
-a, --activate           Activate a site (turn off defaults that ship with new projects)
    --no-git             Don't create a Git repo.
-e, --enable             Enable this host 
-x, --disable            Disable this host
-b, --basedir <arg>      Specify a base directory.
-f, --folder <arg>       Specify which folder to use when creating a new instance.
-n, --name <arg>         Specify a name to use for a new instance. 
-m, --domain <arg>       Specify a domain name to host this particular instance.
-d, --description <arg>  Specify a description for the new instance.
-s, --datasource <arg>   Specify a default datasource for use with the new instance.
    --finalize <arg>     Finalize a Myst instance.
-l, --list               List all the hosts and their status.

Modifiers and server-specific options:
-i, --virtual-host <arg> Create a \$SERVER-style virtual host and an .htaccess file.

General options:
-v, --verbose            Be verbose.
-h, --help               Show this help and quit.
USAGES

	exit $STATUS
}


# Check for dependencies
check() {
	if [ -z "$1" ]
	then 
		printf "check(): No list specified.  Fix this.\n"
		exit 1
	fi	

	IFS='|'
	for n in $1
	do 
		sh -c ${n} 2>/dev/null
		if [ $? -eq 127 ]
		then 
			printf "$PROGRAM_NAME: Dependency '$n' not found.  " > /dev/stderr
			printf "Please install package '$n' using a package manager.\n" > /dev/stderr
		fi
	done
	IFS=" "
}


# Determine whether an argument is a flag or not
detFlag() {
	if [ -z "$1" ]
	then
		echo -1 
	else
		# arg is a single, lonely dash
		if [ ${#1} -eq 1 ] && [ $1 == '-' ] 
		then
			echo 0

		# arg is a short arg flag 
		elif [ ${1:0:1} == '-' ] && [[ ${1:1:1} =~ [a-z] ]]
		then
			echo -1 

		# arg is a long arg flag 
		elif [ ${1:0:1} == '-' ] && [ ${1:1:1} == '-' ]
		then
			echo -1 

		# arg is an arg
		else
			echo 1

		fi
	fi
}


# Check for the config file, and lib files, stopping if either isn't present. 
[ -f $CONF_FILE ] && source $CONF_FILE || {
	printf "$PNAME is not installed yet.  "
	err "Please run 'make install' from $PNAME's source directory.\n"  1
}
#source $CONF_FILE

[ ! -d $PREFIX ] && {
	err "$PNAME didn't install correctly (couldn't find source directory $PREFIX)\n" 1
}


# Catch blank arguments
[ $# -eq 0 ] && usage 0 


# Process any options
while [ $# -gt 0 ]
do
	case "$1" in
		# Administration stuff
		-c|--create)
			DO_CREATE=1
		;;

		-e|--enable)
			DO_ENABLE=1
		;;

		-x|--disable)
			DO_DISABLE=1
		;;

		# Administration stuff
		-u|--update)
			UPDATE=1
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			DIR="$1"
		;;

		# Turn off the 'default' that ships
		-a|--activate)
			DO_ACTIVATE=1
#			CODE=`detFlag "$2"`;
#			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
#			shift
#			THIS_SITE="$1"
		;;

		# Enable the capacity to serve SES URLs via server configuration
	#	-e|--ses|--search-engine-safe)
	#		DO_SES=1
	#	;;

		# Turn off the defaults
		--finalize)
			DO_FINALIZE=1
			CODE=`detFlag "$2"`;
			# If it's -1, what does that mean again?
			test $CODE -eq 1 && DIR="$2" || DIR=$DIR
			shift
		;;

		# Generate a virtual host file for a particular server configuration
		-i|--virtual-host)
			DO_GENVHOST=1; CODE=`detFlag "$2"`;
			test $CODE -eq -1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			test $CODE -eq 1 && VHOST_FILE="$2" || VHOST_FILE=/dev/stdout
			shift
		;;

		# Don't create a git repo
		--no-git)
			NO_GIT=1
		;;

		# Try parsing data.cfm and check for errors before starting
#		-t|--parse-root)
#			DO_TESTJSON=1
#		;;

		# Parameters 
		-f|--at|--folder)
			# Create this directory
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			DIR="$1"
		;;

		# Use a different base directory
		-b|--basedir)
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			BASEDIR="$1"
		;;

		# ...
		-n|--name)
			# Another parameter in data.json
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			NAME="$1"	
		;;

		# Define the domain names that will be used with a site
		-m|--domain)
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			DOMAIN="$1"	
		;;

		# Goes in the README
		-d|--description)
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			DESCRIPTION="$1"	
		;;

		# Specify a datasource
		-s|--datasource)
			CODE=`detFlag "$2"`;
			test $CODE -lt 1 && err "$1 needs an argument, got '${2:-(nil)}'. Exiting..." 1 
			shift
			DATASOURCE="$1"	
		;;

		# List 
		-l|--list)	
			DO_LIST=1
		;;

		# Verbose
		-v|--verbose)	
			VERBOSE=1
		;;

		--help)	
			usage 0
		;;

		--)	break
		;;

		-*)	printf "$PROGRAM_NAME: Unknown argument received: $1\n" > /dev/stderr; usage 1
		;;
	esac
	shift
done

# Handle verbosity
[ $VERBOSE -eq 1 ] && MKDIR_FLAGS="-pv" || MKDIR_FLAGS="-p"
[ $VERBOSE -eq 1 ] && CP_FLAGS="-v" || CP_FLAGS=""
[ $VERBOSE -eq 1 ] && MV_FLAGS="-v" || MV_FLAGS=""

# Set things that could not be set as const values
SRC=$PREFIX
SHAREDIR=$SRC/share/$SYMNAME

# CREATE NEW CMVC INSTANCES
if [ $DO_CREATE -eq 1 ]
then
	# Assume that this is always on when creating (for now)
	DO_SES=1

	# Use Apache's root directory as the default
	if [ ! -z "$DIR" ]
	then
		echo $DIR
		# Create a name if not specified
		[ -z $NAME ] && NAME=`basename $DIR`
	else 
		# Names have always got to be specified
		[ -z $NAME ] && err "No site name specified."

		$HTTPD_PREFIX/bin/httpd -t -D DUMP_RUN_CFG > /dev/null 2>/dev/null || {
			err "Apache is misconfigured on this system... Can't get config..."
		}

		WWWROOT="$( \
			$HTTPD_PREFIX/bin/httpd -t -D DUMP_RUN_CFG 2>/dev/null| \
			grep 'Main DocumentRoot:'| \
			awk '{ print $3 }' | \
			sed 's/"//g' \
		)"

		DIR=$WWWROOT/${DOMAIN:-$NAME}
	fi

	# Then default all other variables if they were not specified.
	DATASOURCE=${DATASOURCE:-"(none)"}
	TITLE=${TITLE:-"$NAME"}
	DOMAIN=${DOMAIN:-"$NAME"}
	DESCRIPTION=${DESCRIPTION:-""}

	# Do smart things with the base directory
	BASEDIR=${BASEDIR:-"/"}
	[ ${#BASEDIR} -gt 1 ] && [ ${BASEDIR:0:1} != '/' ] && BASEDIR="/${BASEDIR}"
	[ ${#BASEDIR} -gt 1 ] && [ ${BASEDIR:$(( ${#BASEDIR} - 1 )):1} != '/' ] && BASEDIR="${BASEDIR}/"

	# It's a good time for a message
	[ $VERBOSE -eq 1 ] && {
		printf "Creating new $PNAME instance with the following parameters.\n"
		#Uses Apache?  `test $NO_GIT -eq 1 && echo "No" || echo "Yes"`
		cat <<EOF
Directory:    $DIR
Base dir:     $BASEDIR
Datasource:   $DATASOURCE
Domain:       $DOMAIN
Title:        $TITLE
Uses Git?     `test $NO_GIT -eq 1 && echo "No" || echo "Yes"`
Description:  
	$DESCRIPTION
EOF
	}

	# Set up a new Myst instance
	[ $VERBOSE -eq 1 ] && printf "\n* Create $PNAME application folders...\n"
	mkdir $MKDIR_FLAGS $DIR/{api,app,assets,components,db,files,log,misc,overrides,routes,setup,sql,std,views}/
	mkdir $MKDIR_FLAGS $DIR/assets/{css,img,js}/
	mkdir $MKDIR_FLAGS $DIR/db/static/
	mkdir $MKDIR_FLAGS $DIR/std/custom/
	mkdir $MKDIR_FLAGS $DIR/std/components/


	# Populate the new instance
	[ $VERBOSE -eq 1 ] && printf "\n* Populating new $PNAME instance...\n"
	cp $CP_FLAGS $SHAREDIR/{Application.cfc,$SYMNAME.cfc,index.cfm,data.cfm,data.cfm.example} $DIR/
	cp $CP_FLAGS $SHAREDIR/app-default.cfm $DIR/app/default.cfm
	cp $CP_FLAGS $SHAREDIR/views-default.cfm $DIR/views/default.cfm
	cp $CP_FLAGS $SHAREDIR/failure.cfm $DIR/std/
	cp $CP_FLAGS $SHAREDIR/setup.cfm $DIR/api/
	cp $CP_FLAGS $SHAREDIR/{4xx,5xx,mime,html}-view.cfm $DIR/std/
	cp $CP_FLAGS $SHAREDIR/components/* $DIR/std/components/
	cp $CP_FLAGS $SHAREDIR/base.cfc $DIR/components/
	[ $VERBOSE -eq 1 ] && echo DONE!


	# Set up Application redirects
	[ $VERBOSE -eq 1 ] && printf "\n* Setting up redirects...\n"
	for _d in app components db log files misc overrides routes setup sql std views
	do 
		[ $VERBOSE -eq 1 ] && echo cp $SHAREDIR/Application-Redirect.cfc $DIR/$_d/Application.cfc
		cp $SHAREDIR/Application-Redirect.cfc $DIR/$_d/Application.cfc
	done
	[ $VERBOSE -eq 1 ] && echo DONE!


	# Set up assets
	[ $VERBOSE -eq 1 ] && printf "\n* Setting up assets...\n"
	cp $CP_FLAGS $SHAREDIR/*.css $DIR/assets/
	[ $VERBOSE -eq 1 ] && echo DONE!


	# Modify the data.cfm in the new directory to actually work
	[ $VERBOSE -eq 1 ] && printf "\n* Modifying data.cfm...\n"
	test -z `uname | grep 'Darwin'` && IS_MAC=0 || IS_MAC=1


	# If we're on an Apple system, the sed commands will have to be different.
	sed -i -e "{
		s/__DATASOURCE__/${DATASOURCE}/;
		s;__COOKIE__;`xxd -ps -l 60 /dev/urandom | head -n 1`;;
		s;__BASE__;${BASEDIR:-"/"};;
		s/__NAME__/${NAME:-"anon"}/;
		s/__AUTHOR__/${AUTHOR:-"Buddy Noone"}/;
		s/__TITLE__/${TITLE:-"Titleless Website"}/;
	}" $DIR/data.cfm
	[ $VERBOSE -eq 1 ] && echo DONE!


	# Also modify the datasource in Application.cfc
	sed -i -e "{
		s/__DATASOURCE__/${DATASOURCE}/
	}" $DIR/Application.cfc
	[ $VERBOSE -eq 1 ] && echo DONE!


	#Create git repo 
	if [ $NO_GIT -eq 0 ]
	then 
		[ $VERBOSE -eq 1 ] && printf "\nCreating the Git repository for this project...\n"
		touch $DIR/.gitignore
		cd $DIR
		git init 1>/dev/null
		cp $SHAREDIR/gitignore $DIR/.gitignore
		git add -f . 1>/dev/null
		git commit -m "Standard first commit." 1>/dev/null
		[ $VERBOSE -eq 1 ] && cd - || cd - 1>/dev/null
		[ $VERBOSE -eq 1 ] && echo DONE!
	fi	
fi



# Update site backend and tools with the newest version from the most current
# HEAD
if [ $UPDATE -eq 1 ]
then
	# Checks 
	[ ! -z "$DIR" ] || { 
		err "No application specified for update." 1
	}

	[ -d "$DIR" ] || {
		printf "The application at folder '$DIR' " > /dev/stderr
		printf "does not seem to exist or is not accessible." > /dev/stderr
		exit 1
	}

	[ -f "$DIR/$SYMNAME.cfc" ] || {
		err "The application at folder '$DIR' does not seem to be a Myst application." 1
	}

	# I don't really need Git to control rollbacks, it's nice, but not necessary
	[ $VERBOSE -eq 1 ] && echo "Pulling latest copy of $SYMNAME repository."
	# TODO: Do a simple HTTP GET for the latest version and untar.  These tools
	# are more or less guaranteed to be present on a system, whereas Git won't.
	git clone $SRCREPO /tmp/myst
	cd /tmp/myst/ && git checkout $STABLE_BRANCH && cd - 1>/dev/null
	mv $MV_FLAGS $DIR/myst.cfc $DIR/myst_.cfc
	cp $CP_FLAGS /tmp/myst/myst.cfc $DIR/
	# Right now, the user will need to look before he/she leaps and merge Application.cfc manually
	cp $CP_FLAGS /tmp/myst/share/Application.cfc $DIR/Application.cfc.new
	# Also explicitly copy the new base.cfc
	cp $CP_FLAGS /tmp/myst/share/base.cfc $DIR/components/
	rm -rf /tmp/myst/
	exit 0
fi


# Generate SES urls for Apache hosts
if [ $DO_SES -eq 1 ]
then
	# Make sure the user specified a directory
	[ ! -z "$DIR" ] || {
		err "No directory specified for extension-less URL setup..." 1
	}

	[ ! -z "${DOMAIN:-$NAME}" ] || {
		err "No domain or site name specified for extension-less URL setup..." 1
	}
	
	# Prepare the new htaccess file
	sed -e "{
		s/@@domain@@/${DOMAIN:-$NAME}/;
		s/@@date@@/`date`/;
	}" $SHAREDIR/default.htaccess > $DIR/.htaccess

	# Add the .htaccess to the repository if .git is activated
	if [ $DO_CREATE -eq 1 ] && [ -d $DIR/.git/ ] 
	then
		cd $DIR
		git add -f .htaccess
		git commit -m "Added .htaccess file for URL handling." 1>/dev/null
		[ $VERBOSE -eq 1 ] && cd - || cd - 1>/dev/null
	fi
fi 


# Create a virtual host for the server engine in use.
if [ $DO_GENVHOST -eq 1 ] || [ $DO_CREATE -eq 1 ]
then
	# Check if we can grab the configuration details
	$HTTPD_PREFIX/bin/httpd -t -D DUMP_RUN_CFG > /dev/null 2>/dev/null || {
		err "Apache is misconfigured on this system... Can't generate virtualhost."
	}

	# Get some configuration details
	APACHE_DOCROOT="$( \
		$HTTPD_PREFIX/bin/httpd -t -D DUMP_RUN_CFG 2>/dev/null| \
		grep 'DocumentRoot:'| \
		awk '{ print $3 }' | \
		sed 's/"//g' \
	)"

	# Name should probably not be turned off
	[ ! -z "${DOMAIN:-$NAME}" ] || {
		err "No domain or site name specified for vitual host..." 1
	}

	# If this is a CREATE run, we'll generate a virtual host and put it in misc/
	[ $DO_CREATE -eq 1 ] && VHOST_FILE=$DIR/misc/apache.vhost

	# Virtual host
	sed -e "{
		s;@@SITEDOMAIN@@;${DOMAIN:-$NAME};;
		s;@@SITENAME@@;${DOMAIN:-$NAME};;
		s;@@ALIASDOMAIN@@;${DOMAIN:-$NAME};
		s;@@WWWROOT@@;${APACHE_DOCROOT};;
		s;@@DATE@@;$( date );;
	}" $SHAREDIR/default.vhost > $VHOST_FILE 

	# Link to virtual-hosts (this is going to work differently on production)
#	ln -s $VHOST_FILE $PREFIX/virt-hosts-available/$NAME || {
#		printf "Failed to create the folder?"
		#This should be deleted?
#	}

	# Lastly, if this is a CREATE run and we haven't done any work, add this file too. 
	if [ $DO_CREATE -eq 1 ] && [ -d $DIR/.git/ ] 
	then
		cd $DIR
		git add -f misc/apache.vhost
		git commit -m "Added Apache virtual host template." 1>/dev/null
		[ $VERBOSE -eq 1 ] && cd - || cd - 1>/dev/null
	fi
fi


# Activate a host (for old sites, or previously disabled ones)
if [ $DO_ACTIVATE -eq 1 ]
then
	# Did we call DO_CREATE?
	if [ -z "$VHOST_FILE" ]
	then
		#In this case, I have to specify a Domain or Name 
		[ -z "${DOMAIN:-$NAME}" ] && err "No site domain or name specified."

		#If this is not done, figure it out
		if [ -z "$DIR" ]
		then
			# Absolute directories can be specified, but aren't needed anymore.
			DIR=$HTTPD_PREFIX/htdocs/${DOMAIN:-$NAME}

			# Check for domain and/or name?
			[ $VERBOSE -eq 1 ] && printf "Activating site '%s'\n" ${DOMAIN:-$NAME}
		fi
		VHOST_FILE=$DIR/misc/apache.vhost
	fi

	# If this file doesn't exist for whatever reason, it's a problem.
	if [ ! -f "$VHOST_FILE" ]
	then
		mkdir $DIR/misc/ || {
			printf "Could not create configuration directory for specified instance at: $DIR" > /dev/stderr
			exit 1
		}

		# Call yourself and create it
		$0 --virtual-host - > $VHOST_FILE || {
			printf "Could not create new virtual host for instance at: $DIR" >/dev/stderr
			exit 1
		}
	fi

	# This file ought to exist now, but something can still go wrong		
	#echo ln -s $VHOST_FILE $PREFIX/virt-hosts-available/${DOMAIN:-$NAME} 
	cd $PREFIX
	#echo ln -s www/misc/apache.vhost virt-hosts-available/${DOMAIN:-$NAME}
	ln -s ../www/${DOMAIN:-$NAME}/misc/apache.vhost virt-hosts-available/${DOMAIN:-$NAME} || {
		printf "Failed to enable site at: $DIR"
		exit 1	
	}
	cd - >/dev/null
fi


# Enable hosts 
if [ $DO_ENABLE -eq 1 ]
then
	[ -z "${DOMAIN:-$NAME}" ] && err "No site or domain specified."

	[ $VERBOSE -eq 1 ] && printf "Enabling site '%s'\n" ${DOMAIN:-$NAME}

#	ln -s $PREFIX/virt-hosts-available/${DOMAIN:-$NAME} $PREFIX/virt-hosts-enabled/ || {
#		printf "Failed to enable site: %s." ${DOMAIN:-$NAME}
#		exit 1	
#	}

	cd $PREFIX
	#echo ln -s www/misc/apache.vhost virt-hosts-available/${DOMAIN:-$NAME}
	ln -s ../virt-hosts-available/${DOMAIN:-$NAME} virt-hosts-enabled/${DOMAIN:-$NAME} || {
		printf "Failed to enable site at: $DIR"
		exit 1	
	}
	cd - >/dev/null
fi


# Disable hosts 
if [ $DO_DISABLE -eq 1 ]
then
	[ -z "${DOMAIN:-$NAME}" ] && err "No site or domain specified."
	[ $VERBOSE -eq 1 ] && printf "Disabling site '%s'\n" ${DOMAIN:-$NAME}
	echo rm -f $PREFIX/virt-hosts-enabled/${DOMAIN:-$NAME} || {
		printf "Failed to disable site: %s." ${DOMAIN:-$NAME}
		exit 1	
	}
fi


# List hosts (notice that this will only list Myst instances) 
if [ $DO_LIST -eq 1 ]
then
	cd $PREFIX
	printf "%-40s Active?  Enabled?\n" "Site"
	printf "%-40s =======  ========\n" "===="
	find www/ -type f -name "myst.cfc" | \
		grep -v "www/_" | \
		xargs dirname | \
		sort | \
		xargs -IFF sh -c \
			'printf "%-40s %-8s %-8s\n" \
				$(basename FF) \
				$(test -h ./virt-hosts-available/`basename FF` && echo @Y || echo @N ) \
				$(test -h ./virt-hosts-enabled/`basename FF` && echo @Y || echo @N ) \
			'
	#	$(stat -c "%x" FF | awk "{ print $1 }") \
	cd - >/dev/null
fi


# The finalize command
if [ $DO_FINALIZE -eq 1 ]
then
	[ ! -z "$DIR" ] || {
		err "No application specified for finalizing." 1
	}
	[ -d "$DIR" ] || {
		err "The application at folder '$DIR' does not seem to exist or is not accessible." 1
	}
	[ -f "$DIR/$SYMNAME.cfc" ] || {
		err "The application at folder '$DIR' does not seem to be a Myst application." 1
	}

	# Check that it's not the same
	RENAME=0
	if [ ! -f $DIR/app/default.cfm ]
	then
		RENAME=1	
	else
		DESTFILE=`sum $DIR/app/default.cfm | awk '{ print $1 }'`
		SRCFILE=`sum $PREFIX/share/myst/app-default.cfm | awk '{ print $1 }'`
		[ $DESTFILE -eq $SRCFILE ] && RENAME=1
	fi

	if [ $RENAME -eq 1 ]
	then
		# [[ `cat $DIR/app/default.cfm` == `cat $PREFIX.cfm` ]] 
		mv $MV_FLAGS $DIR/app/default.cfm $DIR/app/_default.cfm
		mv $MV_FLAGS $DIR/views/default.cfm $DIR/views/_default.cfm
		touch $DIR/{app,views}/default.cfm
	fi	
fi


exit 0
# vim: ff=unix
