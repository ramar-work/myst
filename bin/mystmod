#!/bin/sh -
# -------------------------------------------- #
# mystmod.sh
#
# @author
#		Antonio R. Collins II (rc@tubularmodular.com, ramar.collins@gmail.com)
#
# @copyright
# 	Copyright 2016-Present, "Tubular Modular"
# 	Original Author Date: Tue Jul 26 07:26:29 2016 -0400
# 
# @summary
# 	A way to create new "plugins"
#
# @usage
# 	
#
# 
# @todo
#		- Be able to build from JSON
# 	- Handle setup tasks and tooling ( like database connections and maintenance ) 
# 	- Convert to Java or C++
#		- Download "modules" via some web site somewhere and place them into this chain
# -------------------------------------------- #

# Variable list
PROGRAM_NAME=mystmod
CONF_FILE=/etc/myst.conf
LIB_FILE=share/myst/mystlib.sh

DIR=
ADDR=
EXTRACT_DIR=
MERGE_DIR=
DO_INSTALL=0
DO_EXTRACT=0
DO_MERGE=0
DO_UPLOAD=0
DO_CREATE=0
DO_SETUP=0
DO_COMPRESS=0
#SRC= This will be filled out during the install process...
SRCDIR=.
NO_GIT=0
ERR_NODIR=1
ERR_NONAME=2
VERBOSE=0


# An error function
err() {
	STATUS=${2:-0}
	printf "$PROGRAM_NAME: $1\n" > /dev/stderr
	exit $STATUS
}


# A usage function
usage() {
	STATUS=${2:-0}

	cat <<USAGES
$0:
Creation options:
-c, --create            Create a new module. 
-f, --folder <arg>      Specify which folder to use when creating a new module.
-n, --name <arg>        Specify a name to use for the new module. 
-t, --test-on <arg>     Compresses the current Git HEAD and applies to a Myst instance. 

Install options:
-i, --install <arg>     Choose a module to install.
-e, --extract <arg>     Extract a potential module's files from a live instance.
    --from <arg>        Choose folder or file where the project may be. (BETA)
    --to <arg>          Install the extension to <arg> 

Metadata options:
-a, --author <arg>       Specify an author for the new module.
-d, --description <arg>  Specify a description for the new module.
    --datasource <arg>   Specify a default datasource for use with the new instance.

Post-install options:
    --address <arg>      Specify a web address of an instance for completing module setup.
    --setup              Run module setup routines.
-o, --module <arg>       Load this module during setup if running setup by itself.

-v, --verbose            Be verbose.
-h, --help               Show this help and quit.
USAGES

	exit $STATUS
}


# Check for the config file, and lib files, stopping if either isn't present. 
[ ! -f $CONF_FILE ] && \
	err "$PNAME is not installed yet.  Please run 'make install' from $PNAME's source directory.\n"  1
source $CONF_FILE
[ ! -d $PREFIX ] && err "$PNAME didn't install correctly (couldn't find source directory $PREFIX)\n" 1
[ ! -f $PREFIX/$LIB_FILE ] && err "$PNAME didn't install correctly (couldn't find $LIB_FILE)\n" 1
source $PREFIX/$LIB_FILE


# Catch blank arguments
[ $# -eq 0 ] && usage 0 


# Process any options
while [ $# -gt 0 ]
do
	case "$1" in
		# Specify a web address to help the install process
		-a|--address)
			shift
			ADDR="$1"
		;;

		# This is for something
		--directory)
			shift
			EXTRACT_DIR="$1"
		;;

		# Administration stuff
		--setup)
			DO_SETUP=1
		;;

		# Administration stuff
		-c|--create)
			DO_CREATE=1
		;;

		--apachify)
			# Create an Apache style virtual host and an .htaccess file
			APACHIFY=1
		;;

		--no-git)
			# Don't create a git repo
			NO_GIT=1
		;;

		# Parameters 
		-f|--folder)
			# Create this directory
			shift
			DIR="$1"
		;;

		-e|--extract)
			# Specify which engine so the right virtual host file will be generated
			DO_EXTRACT=1
			shift
			MODNAME="$1"
		;;

		-a|--author)
			shift
			AUTHOR="$1"	
		;;

		-n|--name)
			shift
			MODNAME="$1"	
		;;

		# This is just going to be the name...
		-i|--install)
			DO_INSTALL=1	
			shift
			MODNAME="$1"	
		;;

		-o|--module)
			shift
			MODITEM="$1"	
		;;

		--from)
			shift
			MODPATH="$1"
		;;

		--to)
			# Another parameter in data.json
			shift
			FOLDER="$1"	
		;;

		-m|--domain)
			# This isn't truly necessary, but it can be used in data.json 
			shift
			DOMAIN="$1"	
		;;

		-d|--description)
			# Goes in the README
			shift
			DESCRIPTION="$1"	
		;;

		-s|--datasource)
			# Specify a datasource
			shift
			DATASOURCE="$1"	
		;;

		-v|--verbose)	
			# Verbose
			VERBOSE=1
		;;

		--help)	
			usage 0
		;;

		--)	break
		;;

		-*)	printf "$PROGRAM_NAME: Unknown argument received: $1\n" > /dev/stderr; usage 1
		;;
	esac
	shift
done


# The create routines.
if [ $DO_CREATE -eq 1 ]
then
	test ! -z $MODNAME || err "No module name specified." 1
	test ! -z $DIR || err "No directory specified." 1

	mkdir -pv $DIR/{api,app,assets,components,db,routes,setup,sql,std,views}/$MODNAME/

	# Set this now
	SRCDIR=$PREFIX

	for ff in Makefile README.md components/standard.cfc
	do
		DASH_COUNT=`echo $MODNAME | sed 's/[0-9,A-Z,a-z]/-/g'`
		BASENAME=`basename $ff`	
		sed "{
			s/__MODNAME__/$MODNAME/g ; 
			s/__DASHES__/$DASH_COUNT/g ;
			s/__SUMMARY__/${SUMMARY:-''}/g ;
			s/__DESCRIPTION__/${DESCRIPTION:-''}/g ;
			s/__AUTHOR__/${AUTHOR:-''}/g ;
			s/__USAGE__/${USAGE:-''}/g ;
		}" $SRCDIR/share/myst/$PROGRAM_NAME/$BASENAME > $DIR/$ff
	done

	mv -v $DIR/components/standard.cfc $DIR/components/$MODNAME.cfc

	if [ $NO_GIT -eq 1 ]
	then	
		cd $DIR
		git init
		git add .
		git commit -m "Initial commit of module '$MODNAME'"
		cd -
	fi

	[ $VERBOSE -eq 1 ] && printf "Successfully created module '$MODNAME'\n" 
fi


# Upload files to repo.mystframework.com
if [ $DO_UPLOAD -eq 1 ]
then
	echo ''
	# Extract the description, name and other things from README.md and tar it and upload it
	# The user would have to pre-register, so there's that...
fi


# Compress a module and it's assets/dependencies
if [ $DO_COMPRESS -eq 1 ]
then
	echo ''
	tar 2>/dev/null
fi


# Install something to somewhere
if [ $DO_INSTALL -eq 1 ]
then
	# The folder where we're going to put the module
	[ -z "$FOLDER" ] && err "No folder specified to put the new module." 1

	# Not now, but I will need this in the future to locate paths 
	[ -z "$MODNAME" ] && err "No module name specified." 1

	# Should be able to install either from disk, git or web
	[ -z "$MODPATH" ] && err "No module path specified." 1

	# A pretty message
	[ $VERBOSE -eq 1 ] && printf "Installing $MODNAME into $FOLDER (from $MODPATH)...\n"

	# Git 
	if [[ ${MODPATH:0:6} == "git://" ]]
	then
		printf "Clone from git repo: $MODPATH\n"
	# you might need to check that the host exists here...
	# git clone $MODPATH /tmp/$MODITEM || handle failure
	# cd /tmp/$MODPATH && ( git --extract-head... | tar xf - -C $FOLDER/ )

	# Web
	elif [[ ${MODPATH:0:7} == "http://" ]] ||[[ ${MODITEM:0:8} == "https://" ]] 
	then
		printf "Pull from HTTP/HTTPS: $MODPATH\n"
	# ghostbyname ${MODPATH%%...}  # Just pull the hostname and look
		wget -O- $MODPATH | tar xzf - --verbose -C $FOLDER/

	# Assume that this is from a disk 
	else
		printf "Copy from disk: $MODPATH\n"
exit
		stat $MODPATH 1>/dev/null 2>/dev/null || err "File $MODITEM not found..."
		# Distinguish between files and stuff
		cd $MODPATH
		tar cf - . | tar xf - --verbose -C $FOLDER/
		cd -
	fi
fi


# Complete any setup of any kind
if [ $DO_SETUP -eq 1 ]
then
	[ -z "$MODITEM" ] && err "Can't setup unnamed package (use --module)" 1
	[ -z "$ADDR" ] && err "Can't setup the package with no web address. (Specify where the instance lives with --addr \$WWW)"
	[ $VERBOSE -eq 1 ] && echo "wget $ADDR/api/setup.cfm?file=setup.sql&module=$MODITEM"
	# Let's see the header and response text on the command line, cut any leading spaces or tabs
	wget --quiet -O- "$ADDR/api/setup.cfm?file=setup.sql&module=$MODITEM" | sed 's/^[\t, ]//g'
fi


# Extract
if [ $DO_EXTRACT -eq 1 ]
then
	# check that there is actually an instance
	[ -z "$MODNAME" ] && err "Can't extract unspecified package (--extract needs an argument)." 1
	[ -z "$FOLDER" ] && err "No folder to extract module from (use --folder)." 1
	[ -z "$EXTRACT_DIR" ] && err "No directory for creation specified (use --directory)" 1
	# check that there is a module specified
	# echo $MODNAME $FOLDER $EXTRACT_DIR

	# Make a place for modules...
	EXDIR=$EXTRACT_DIR/$MODNAME
	mkdir -pv $EXDIR/
	mkdir -pv $EXDIR/{api,app,assets,components,db,routes,setup,sql,std,views}/

	# The thing
	for ff in api app assets setup sql views
	do
		[ -d $FOLDER/$ff/$MODNAME/ ] && cp -rv $FOLDER/$ff/$MODNAME/ $EXDIR/$ff/
	done

	# ???
	[ -f "$FOLDER/components/${MODNAME}.cfc" ] && cp -v $FOLDER/components/${MODNAME}.cfc $EXDIR/components/
	[ -f "$FOLDER/routes/${MODNAME}.cfm" ] && cp -v $FOLDER/routes/${MODNAME}.cfm $EXDIR/routes/
fi


# Merge 
if [ $DO_MERGE -eq 1 ]
then
	# check that there is actually an instance
	[ -z "$MODNAME" ] && err "Can't extract unspecified package (--extract needs an argument)." 1
	[ -z "$FOLDER" ] && err "No folder to extract module from (use --folder)." 1
	[ -z "$MERGE_DIR" ] && err "No directory for creation specified (use --directory)" 1
	# check that there is a module specified
	# echo $MODNAME $FOLDER $EXTRACT_DIR

	# Make a place for modules...
	mkdir -pv /tmp/$MODNAME/{api,app,assets,components,db,routes,setup,sql,std,views}/

	# Integrate the files and any dependencies 
	for ff in api app assets components setup sql views
	do
		[ -d $FOLDER/$ff/$MODNAME/ ] && cp -rv $FOLDER/$ff/$MODNAME/ /tmp/$MODNAME/$ff/
	done

	# ???
	[ -f "$FOLDER/components/${MODNAME}.cfc" ] && \
		cp -v $FOLDER/components/${MODNAME}.cfc /tmp/$MODNAME/components/
	[ -f "$FOLDER/routes/${MODNAME}.cfm" ] && \
		cp -v $FOLDER/routes/${MODNAME}.cfm /tmp/$MODNAME/routes/

	# Finally, tarball this and copy over the original repository (which should be a git repo) 
	# I have to choose a repo type (the web is going to be the best choice)
	# tar cf - /tmp/$MODNAME # | tar xf - -C $REPO/

fi
exit 0

#cp $SRC/share/apache_htaccess $DIR/.htaccess
# vim: ff=unix
