#!/bin/sh -
# -------------------------------------------- #
# mystmod.sh
#
# @author
#		Antonio R. Collins II (rc@tubularmodular.com, ramar.collins@gmail.com)
#
# @copyright
# 	Copyright 2016-Present, "Tubular Modular"
# 	Original Author Date: Tue Jul 26 07:26:29 2016 -0400
# 
# @summary
# 	A way to create new "plugins"
#
# @usage
# 	
#
# 
# @todo
#		- Be able to build from JSON
# 	- Handle setup tasks and tooling ( like database connections and maintenance ) 
# 	- Convert to Java or C++
#		- Download "modules" via some web site somewhere and place them into this chain
# -------------------------------------------- #

# Variable list
PROGRAM_NAME=mystmod
CONF_FILE=/etc/myst.conf
LIB_FILE=share/myst/mystlib.sh

DIR=
DO_INSTALL=0
DO_UPLOAD=0
DO_CREATE=0
DO_COMPRESS=0
#SRC= This will be filled out during the install process...
SRCDIR=.
NO_GIT=0
ERR_NODIR=1
ERR_NONAME=2
DO_VERBOSE=0


# An error function
err() {
	STATUS=${2:-0}
	printf "$PROGRAM_NAME: $1\n" > /dev/stderr
	exit $STATUS
}


# A usage function
usage() {
	STATUS=${2:-0}

	cat <<USAGES
$0:
Creation options:
-c, --create            Create a new module. 
-f, --folder <arg>      Specify which folder to use when creating a new module.
-n, --name <arg>        Specify a name to use for the new module. 
-t, --test-on <arg>     Compresses the current Git HEAD and applies to a Myst instance. 

Install options:
-i, --install <arg>     Choose a module to install.
    --from <arg>        Choose folder or file where the project may be. (BETA)
    --to <arg>          Install the extension to <arg> 

Metadata options:
-a, --author <arg>       Specify an author for the new module.
-d, --description <arg>  Specify a description for the new module.
    --datasource <arg>   Specify a default datasource for use with the new instance.

-v, --verbose            Be verbose.
-h, --help               Show this help and quit.
USAGES

	exit $STATUS
}


# Check for the config file, and lib files, stopping if either isn't present. 
[ ! -f $CONF_FILE ] && \
	err "$PNAME is not installed yet.  Please run 'make install' from $PNAME's source directory.\n"  1
source $CONF_FILE
[ ! -d $PREFIX ] && err "$PNAME didn't install correctly (couldn't find source directory $PREFIX)\n" 1
[ ! -f $PREFIX/$LIB_FILE ] && err "$PNAME didn't install correctly (couldn't find $LIB_FILE)\n" 1
source $PREFIX/$LIB_FILE


# Catch blank arguments
[ $# -eq 0 ] && usage 0 


# Process any options
while [ $# -gt 0 ]
do
	case "$1" in
		# Administration stuff
		-c|--create)
			DO_CREATE=1
		;;

		--apachify)
			# Create an Apache style virtual host and an .htaccess file
			APACHIFY=1
		;;

		--no-git)
			# Don't create a git repo
			NO_GIT=1
		;;

		# Parameters 
		-f|--folder)
			# Create this directory
			shift
			DIR="$1"
		;;

		-e|--engine)
			# Specify which engine so the right virtual host file will be generated
			shift
			ENGINE="$1"	
		;;

		-a|--author)
			shift
			AUTHOR="$1"	
		;;

		-n|--name)
			shift
			MODNAME="$1"	
		;;

		-i|--install)
			DO_INSTALL=1	
			shift
			MODITEM="$1"	
		;;

		--from)
			# Another parameter in data.json
			shift
			MODNAME="$1"	
		;;

		--to)
			# Another parameter in data.json
			shift
			FOLDER="$1"	
		;;

		-m|--domain)
			# This isn't truly necessary, but it can be used in data.json 
			shift
			DOMAIN="$1"	
		;;

		-d|--description)
			# Goes in the README
			shift
			DESCRIPTION="$1"	
		;;

		-s|--datasource)
			# Specify a datasource
			shift
			DATASOURCE="$1"	
		;;

		-v|--verbose)	
			# Verbose
			VERBOSE=1
		;;

		--help)	
			usage 0
		;;

		--)	break
		;;

		-*)	printf "$PROGRAM_NAME: Unknown argument received: $1\n" > /dev/stderr; usage 1
		;;
	esac
	shift
done


if [ $DO_CREATE -eq 1 ]
then
	test ! -z $MODNAME || err "No module name specified." 1
	test ! -z $DIR || err "No directory specified." 1

	mkdir -pv $DIR/{app,assets,components,db,routes,setup,sql,std,views}/$MODNAME/

	# Set this now
	SRCDIR=$PREFIX

	for ff in Makefile README.md components/standard.cfc
	do
		DASH_COUNT=`echo $MODNAME | sed 's/[0-9,A-Z,a-z]/-/g'`
		BASENAME=`basename $ff`	
		sed "{
			s/__MODNAME__/$MODNAME/g ; 
			s/__DASHES__/$DASH_COUNT/g ;
			s/__SUMMARY__/${SUMMARY:-''}/g ;
			s/__DESCRIPTION__/${DESCRIPTION:-''}/g ;
			s/__AUTHOR__/${AUTHOR:-''}/g ;
			s/__USAGE__/${USAGE:-''}/g ;
		}" $SRCDIR/share/myst/$PROGRAM_NAME/$BASENAME > $DIR/$ff
	done

	mv -v $DIR/components/standard.cfc $DIR/components/$MODNAME.cfc

	if [ $NO_GIT -eq 1 ]
	then	
		cd $DIR
		git init
		git add .
		git commit -m "Initial commit of module '$MODNAME'"
		cd -
	fi

	[ $DO_VERBOSE -eq 1 ] && printf "Successfully created module '$MODNAME'\n" 
fi


# Upload files to repo.mystframework.com
if [ $DO_UPLOAD -eq 1 ]
then
	echo ''
	# Extract the description, name and other things from README.md and tar it and upload it
	# The user would have to pre-register, so there's that...
fi



# Compress a module and it's assets/dependencies
if [ $DO_COMPRESS -eq 1 ]
then
	echo ''
	tar 2>/dev/null
fi


# Install something to somewhere
if [ $DO_INSTALL -eq 1 ]
then
	
	# ...
	[ -z "$FOLDER" ] && err "$FOLDER unspecified." 

	# Should be able to install either from disk, git or web
	[ -z "$MODITEM" ] && err "No module name specified."

	printf "Installing $MODITEM into $FOLDER...\n"

	# Git 
	if [[ ${MODITEM:0:6} == "git://" ]]
	then
		printf "Clone from git repo: $MODITEM\n"
	# you might need to check that the host exists here...
	# git clone $MODITEM /tmp/$MODITEM || handle failure
	# cd /tmp/$MODITEM && ( git --extract-head... | tar xf - -C $FOLDER/ )

	# Web
	elif [[ ${MODITEM:0:7} == "http://" ]] ||[[ ${MODITEM:0:8} == "https://" ]] 
	then
		printf "Pull from HTTP/HTTPS: $MODITEM\n"
	# ghostbyname ${MODITEM%%...}  # Just pull the hostname and look
		wget -O- $MODITEM | tar xzf - --verbose -C $FOLDER/

	# Assume that this is from a disk 
	else
		printf "Copy from disk: $MODITEM\n"
		stat $MODITEM 1>/dev/null 2>/dev/null || err "File $MODITEM not found..."
		# Distinguish between files and stuff
		cd $MODITEM
		tar cf - . | tar xf - --verbose -C $FOLDER/
		cd -
	fi

	# Assume 
fi


exit




#cp $SRC/share/apache_htaccess $DIR/.htaccess
# vim: ff=unix
